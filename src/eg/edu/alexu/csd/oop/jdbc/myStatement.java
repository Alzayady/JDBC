package eg.edu.alexu.csd.oop.jdbc;
import eg.edu.alexu.csd.oop.db.DB;
import java.sql.*;
import java.util.LinkedList;
import java.util.concurrent.locks.ReentrantLock;

public class myStatement implements Statement {

    private DB db ;
    private myConnection connection ;
    private LinkedList<String> batchList = new LinkedList<>();

    private ReentrantLock lock = new ReentrantLock();
    public myStatement(myConnection connection){
        this.connection = connection;
        this.db = connection.getDataBase();
    }
    private int time=0;

    private boolean endProcess=true;


    private boolean fail=false;



    private void rulesBefore() throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");
        endProcess=false;
        (new Thread(new COUNT())).start();
    }
    private void rulesAfter() throws SQLException {
        if(fail){
            throw new SQLException("QueryTimeout finished before ending process ");
        }
        endProcess=true;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        rulesBefore();

        myResultSet resultSet= new myResultSet(this,db.executeQuery(sql),db.getSelectedHeaders()
                ,db.getSelectedTypes(),db.getSelectedTable().getName());

        rulesAfter();
        return resultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        int num;
        try {
            num=  db.executeUpdateQuery(sql);
        } catch (Exception e) {
            throw new SQLException();
        }
        return num;
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        if(sql.matches("((?i)^\\s*insert.+$)") ||
                sql.matches("((?i)^\\s*update.+$)") || sql.matches("((?i)^\\s*delete.+$)") ){
            return executeUpdate(sql) != 0;
        }
        else if(sql.matches("((?i)^\\s*select.+$)") ){
            return executeQuery(sql).next();
        }
        else {
            rulesBefore();
            boolean b= db.executeStructureQuery(sql);
            rulesAfter();
            return b;
        }

    }

    @Override
    public void addBatch(String sql) throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");

        batchList.add(sql);
    }

    @Override
    public void close() throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");

        ((myConnection)this.getConnection()).removeStatement(this);
        lock.lock();
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");

        return 0;
    }

    @Override
    public void clearBatch() throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");

        batchList = new LinkedList<>();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        rulesBefore();
        int[] batchExcution = new int[batchList.size()];
        for(int i=0;i<batchList.size();i++){
            batchExcution[i] = executeUpdate(batchList.get(i));
        }
        rulesAfter();
        return batchExcution;
    }

    @Override
    public Connection getConnection() throws SQLException {
        if(this.isClosed())throw new SQLException("this statement is already  closed ");
        return connection ;
    }

    @Override
    public boolean isClosed() throws SQLException {
        return lock.isLocked();
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        if(seconds>=0){
            time=seconds;
        }else{
            System.out.println("time must be >=0" );
        }
    }


    private class COUNT implements Runnable{

        @Override
        public void run() {
            if(time==0)return;
            try {
                Thread.sleep(time*1000);
            }catch (InterruptedException e){

            }
            if(!endProcess){
                fail=true;
            }else {
                fail=false;
            }
        }
    }
































    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public int getMaxRows() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }



    @Override
    public void cancel() throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public void clearWarnings() throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public void setCursorName(String name) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int getUpdateCount() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public int getFetchDirection() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public int getFetchSize() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int getResultSetType() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }



    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public boolean isPoolable() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        throw new java.lang.UnsupportedOperationException();

    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        throw new java.lang.UnsupportedOperationException();
    }


}